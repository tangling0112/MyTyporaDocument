# C++

## 第一部分

### 数据类型

#### 变量

**定义方式**：`数据类型`  `变量名` = `变量初始值`

|         数据类型          |                  占用空间                  |    取值范围     |
| :-----------------------: | :----------------------------------------: | :-------------: |
|       short(短整型)       |                2字节,16bit                 |  -2^15~2^15-1   |
|         int(整型)         |                4字节,32bit                 |  -2^31~2^31-1   |
|       long(长整型)        | 4字节,32bit或Linux32的32bit,Linux64的64bit |  -2^31~2^31-1   |
|    long long(超长整型)    |                8字节,64bit                 |  -2^63~2^63-1   |
|    float(单精度浮点数)    |                4字节,32bit                 |   7位有效数字   |
|   double(双精度浮点数)    |                8字节,64bit                 | 15-16位有效数字 |
|        char(字符)         |                 1字节,8bit                 |    一个字符     |
|       char 变量名[]       |                  指定字节                  |   指定个字符    |
| string(需include<string>) |                                            |                 |
|     bool(true/false)      |                 1字节,8bit                 |       1/0       |

#### 常量

- `const` `数据类型` `常量名` = `常量值`
- `#define` `常量名` `常量值`
- **特性**:常量的值不可被任何操作修改 ,如果我们试图修改则会报错

### 常用计算符号

| 符号 | 作用          |
| ---- | ------------- |
| +    | 加法          |
| -    | 减法          |
| *    | 乘法          |
| /    | 除法          |
| %    | 取余数        |
| ++   | 自增          |
| --   | 自减          |
| =    | 赋值          |
| a+=b | 等价于a = a+b |
| a-=b | 等价于a = a-b |
| a*=b | 等价于a = a*b |
| a/=b | 等价于a = a/b |
| a%=b | 等价于a = a%b |
| ==   | 等于          |
| !=   | 不等于        |
| <    | 小于          |
| >    | 大于          |
| >=   | 大于等于      |
| <=   | 小于等于      |
| !    | 非            |
| &&   | 与            |
| \|\| | 或            |

### 结构体

- 结构体的定义:`struct 结构体名 {结构体成员}`

- 创建结构体变量

  - `struct 结构体名 变量名`

  - `struct 结构体名 变量名 = {结构体成员值1,值2...}`

  - 在结构体定义时便定义好

    ```C++
    struct Student{
    	string name;
    	int age;
    	double score;
    }变量名;
    ```

#### 结构体数组

- 前提:结构体已经定义好
- 定义方式
  - `struct 结构体名 数组名[结构体个数]`
  - `struct 结构体名 数组名[结构体个数] = {{结构体1成员值(以逗号分隔)},{结构体2成员值}...}`
- 结构体数组的访问
  - `结构体数组名[结构体索引].结构体成员名`

#### 结构体指针

- 前提:结构体已经定义好
- 定义方式
  - `struct 结构体名* 结构体指针名 = &结构体变量名`
  - `struct 结构体名* 结构体指针名`   `结构体指针名=&结构体变量名`
- 通过指针访问结构体成员
  - `结构体指针名->成员名`

#### 结构体的`.`方法与`->`方法

- `.`:用于访问结构体变量的成员

  ```c++
  结构体变量名.成员名
  Student.name
  ```

- `->`:用于访问结构体指针的成员

  ```c++
  结构体指针->成员名
  strcut Student* zs
  zs->name
  ```

#### 结构体的嵌套

##### 普通结构体嵌套普通结构体

- 通过`结构体变量名.子结构体变量名.子结构体的成员名`的方式来访问子结构体的成员

```c++
struct Student{
    string name;
    int age;
    int score;
};
struct teacher{
    string name;
    int age;
    struct Student student;
};
```

##### 普通结构体嵌套指针结构体

- 通过`结构体变量名.子结构体变量名->子结构体成员名`来访问子结构体成员
- :red_circle: **注意**:当我们创建了一个指向主结构体的结构体指针时通过`结构体指针名->子结构体变量名->子结构体成员`来访问子结构体成员

```c++
struct Student{
    string name;
    int age;
    int score;
};
struct teacher{
    string name;
    int age;
    struct Student* student;
};
```

##### 结构体传参

- **传地址**
  - 形式参数应该定义为`struct 结构体名* 结构体指针名`
  - 直接传递`&结构体变量名`
  - 然后使用`形式参数名->结构体成员名`即可访问
  - :red_circle: **特性**:**在子函数中修改结构体变量的成员,主函数中对应的结构体变量的成员也会发生修改**
- **传值**
  - 形式参数定义为`struct 结构体名 形式参数名`
  - 直接传递`结构体变量名`
  - 然后使用`形式参数名.结构体成员名`即可访问
  - :small_red_triangle:**特性**:**在子函数中无论如何修改结构体变量的成员,主函数中的对应结构体变量的成员都不会被修改**

##### 结构体中使用const

- 定义方式
  - `const struct 结构体名 结构体变量名`
  - `const struct 结构体名 结构体变量名`
- 作用
  - 一般用在结构体传地址时,避免子函数内修改结构体变量的成员.这样做**既可以保证主函数的结构体变量不被修改,又可以利用传递指针来节省内存空间**

##### 值传递与地址传递

- `变量,数组,结构体`都具备`值传递`与`地址传递`两种传递参数的方式
- **值传递**
  - 形式参数定义为普通数据类型
  - **不修改**主函数内被传值的对象
- **地址传递**
  - 形式参数定义为对应的指针
  - **修改**主函数内被传地址的对象

### C++内存模型

#### 代码区

#### 全局区

#### 栈区

#### 堆区

### new运算符分配地址与delete释放内存

- new分配地址

  ```c++
  基本语法：数据类型* 指针名 = new 数据类型(指针指向的内存中存储的值)
  
  创建一般变量,例子如下:
  int* 指针名 = new int(10);
  string* 指针名 = new string('这是一个字符串');
  
  创建数组,例子如下:
  int* 指针名 = new int[10];构造了一个长度为10的一维数组
  ```

- delete释放内存地址

  ```C++
  基本语法:delete 指针名
  ```

### :yellow_heart: 静态变量

- 定义方式
  - `static 数据类型 变量名`
  - `static 数据类型 变量名 = 变量初始值`
- :blue_heart: **特性**:静态变量只有主函数被释放时才会被释放,即所有被主函数调用的函数,以及这些函数调用的函数创建的静态变量,都只会在主函数被释放时才会被释放.

### :red_circle: 引用

- 作用:用于给变量起别名
- 语法:`数据类型 &别名 = 原名`
- **特性**:此时的别名与原名都共享同一块内存,因此通过别名进行修改,原名的值也会修改
- ==`经典作用`:可以用于函数传参时,以`&别名`作为形式参数,**这样我们的子函数就可以修改主函数中被传递的变量的值,而不用借助指针来进行操作,注意,此时传参时直接传变量名即可,不用传地址**==
- **注意**
  - 引用的创建必须严格按照语法进行
  - 引用创建后就不能改变(b应用了a,那么b就无法被修改为c的引用)

#### 引用作为函数的返回值

- **作用**:

- **前提**

  - **不要传递函数的局部变量**的引用(因为其在函数结束执行后,局部变量就会被自动释放)

- **特性**:当我们的函数返回引用时,我们的函数就可以作为赋值运算的左值

  ```C++
  func() = 1000
  会修改func()函数返回的变量的值,我们再使用别名来进行获取时,其值就会变成修改后的值
  ```

- **定义方法**

  ```C++
  int& 函数名(){
  	语句体
  	return 变量名
  }
  调用方法:
  
  int& 别名 = 函数名()
      
  例子:
  int& func(){
  	static int a = 10
  	return a
  }
  调用方法:
  int& b = func()
  ```

#### 引用的本质

- `int &别名 = 原名`等价于`int* const 别名 = &原名`
- 并且在我们使用别名时也会自动转换为`*别名`

#### 以常量形式引用

- `const 数据类型&别名 = 原名`
- **特性**:此时我们无法通过这样创建的别名来修改原名的值,要修改的话我们只能通过原名来进行.
- **等价于**`const 数据类型* const 别名 = &原名`

## 第二部分

### 函数的高阶操作

#### 函数传参

- 基本类型

  - 一般参数:`数据类型 形式参数名`
  - 默认参数:`int 形式参数名 = 默认值`

  - 占位参数:`数据类型`或`数据类型 = 默认值`
    - 作用:

- 注意

  - 形式参数必须从左到右先是**一般参数**,再是**默认参数**,再是**占位参数**

  - ==**一般我们都是在函数的声明中给出默认参数.我们必须确保函数的声明与函数的定义时只有一个定义默认参数**==

    ```C++
    int func(int a,int b=10);声明
    int func(int a,int b);定义
    或
    int func(int a, int b);声明
    int func(int a, int b=10);定义
    下面是错误的
    int func(int a, int b=10);声明
    int func(int a, int b=10);定义
    ```

#### 函数重载

- ==作用:支持多个函数同名,根据我们传递的参数,来调用同名函数中的某一个==
- **条件**
  - 同名函数在同一作用域
  - 同名函数之间在参数数量,参数顺序,参数类型三者中至少有一个不同
- 引用作为参数的重载
  - `const 数据类型 &别名`与`数据类型 &别名`是不同的是可以正确创建重载的
    - 传变量那么进第二个
    - 传常量那么进第一个
- 默认参数的重载
  - `数据类型 形式参数名`与`数据类型 形式参数名 = 默认值`是**不可以**正确创建重载的
  - `数据类型 形式参数名`与`,数据类型 形式参数名,数据类型 形式参数名 = 默认值`是可以正确创建重载的,但是当我们不给默认值传递参数时,程序就不知道进哪一个函数,就会报错.因此尽量不要在涉及重载时使用默认参数

### 类与对象

#### 类

- 三大特性:==封装,继承,多态==

##### 封装

##### 使用class定义类

- 基本语法:`class 类名(访问权限 类属性 类方法 访问权限 类属性 类方法...)`

  ```c++
  class Circle{
  public:
      int r;
      double caculate(){
          return 2*3.14*r;
      };
  };
  ```

- **特性**

  - ==我们必须使用`类名 类对象名`来实例化类对==
  - 类内的属性属于类作用域下的全局变量,因此类中的任意方法都可以直接调用,修改类内的属性.
  - ==我们可以使用`实例化的类对象名.属性`的方式来访问实例化的类对象的属性==
  - ==我们可以使用`实例化的类对象名.方法()`的方式来调用实例化的类对象的方法==

##### :red_circle: 访问权限

- `public`:``public`的类内**属性与方法**,**可以**被类内方法访问,也**可以**通过`类实例.`的方式访问,还**可以被继承了该类的子类访问**

- `private`:`private`的类内属性与方法,**只能**被类内的方法访问,**不可以**通过`类实例.`的方式访问,也**不能被继承了该类的子类访问**

- `protected`:`protected`的类内**属性与方法**,**只能**被类内的方法访问,**不可以**通过`类实例.`的方式访问,但**可以被继承了该类的子类访问**

- ```C++
  //创建Persong类
  class Person{
  public:
  	string name;
  protected:
  	string car;
  private:
  	string passward;
  };
  //建立继承Persong类的子类
  
  ```

##### 使用`struct`定义类

- ==与`class`的区别:`struct`的默认权限为`public`,而`class`的默认权限为`private`==

- 实例

  ```c++
  struct Person{
  	string name;
      int func(){
          cout << '函数' << endl;
      };
  };
  ```

#### 对象

##### 对象的清理与初始化

- 作用：即每一个对象在被创建时以及被销毁时都需要有对应的设置。而**构造函数**与**析构函数**就是用来实现这一点的

- ==**构造函数**==：在类被实例化时自动调用

  - **基本语法**：`类名(函数参数){语句体}`
  - **特性**
    - 没有返回值,不用写`return`
    - 函数名与类名相同
    - 可以有参数,可以重载
    - 对象被创建时,该函数会被自动调用

- ==**析构函数**==：在类实例被销毁时自动调用

  - **基本语法**:`~类名(函数参数){语句体}`
  - **特性**
    - 没有返回值,不用写`return`
    - 函数名称为`~类名`
    - 不可以有参数,也不可以重载
    - 对象被销毁时会自动调用

- 实例

  ```C++
  class Person{
  	string name;
  	Person(){
  		cout << '调用构造函数' << 'endl';
  	}
  	~Person(){
  		cout << '调用析构函数' << 'endl';
  	}
  }
  ```

##### 构造函数的分类与调用

###### 分类

- 按照参数分类
  - 有参数构造
  - 无参数构造
- 按照类型分类
  - 普通构造函数
  - ==拷贝构造函数==
    - 语法:`类名(const 类名 &任意名称){}`
    - **作用**:将指定类的引用传递给构造函数

###### ==调用==

- ==括号法==
  - `类名 对象名`:自动调用**无参数**构造函数
  - `类名 对象名(参数)`:自动调用**有参数**构造函数
  - `类名 对象名(已存在对象)`:自动调用**拷贝**构造函数
  - **注意**:若要调用无参数构造函数一定不能用`类名 对象名()` 
- 显示法
  - `类名 对象名 = 类名`:自动调用**无参数**构造函数
  - `类名 对象名 = 类名(参数)`:自动调用**有参数**构造函数
  - `类名 对象名 = 类名(已存在对象)`:自动调用**拷贝**构造函数
- 隐式转换法
  - `类名 对象名 = 参数`:等价于`类名 对象名(参数)`
  - `类名 对象名 = 已存在对象`等价于`类名 对象名(已存在对象)`

##### 匿名对象

- `类名`或`类名(参数)`
- **注意**:`类名(对象名)`等价于`类名 对象名`

##### ==拷贝构造函数的作用==

- 语法:`类名(const 类名 &任意名称){}`
- 作用
  - ==用于在创建一个新类时,通过拷贝构造函数,给新类的一部分属性初始化为已经存在的类的属性的值或方法的返回值==
  - 值传递类时被调用(原因在于值传递等价于`类名 形式参数名 = 被传递的类的名称`,这就是一个隐式转换法的拷贝构造函数调用)
  - 值方式返回类时被调用(原因在于在主函数中为`函数的返回值类型 对象名 = 函数名()`这就等价于`类名 对象名 = 即将被销毁的类的名称`,这也是一个隐式转换法的拷贝构造函数调用)

##### 构造函数的调用规则

- 默认情况下,编译器会自动给类创建
  - **无参构造函数(函数体为空,没有实际作用)**
  - **析构函数(函数体为空,没有实际作用)**
  - **拷贝构造函数(会自动实现属性拷贝)**
- 若我们**自定义**了**有参构造**函数,则**只会**自动创建**拷贝构造函数(会自动实现属性拷贝)**
- 若我们**自定义**了**拷贝构造**参数,则**不会**自动创建任何构造函数(**此时便不会实现自动属性拷贝**)
- :red_circle:  **注意**:由于在一定情况下,编译器不会自动生成构造函数,因此我们应该在调用析构函数之前考虑是否存在该函数.

##### ==深拷贝与浅拷贝==

- 浅拷贝:通过简单的赋值来进行拷贝,并且对于指针类型的属性则直接传地址(编译器自动实现的拷贝就是浅拷贝)

  - **问题**:我们通过浅拷贝创建的第二个类对象的指针与原类对象指向的是同一个内存地址,因此当我们释放了两者任意一个指针指向的内存地址后,如果在用另外一个再次执行内存地址释放操作,就会引起内存释放的非法操作.因此对于指针属性,我们应该尽可能地使用深拷贝来进行拷贝操作.

- 深拷贝:在堆区申请新的空间来进行拷贝

  - 由于在拷贝构造时,会申请新的堆区内存空间进行存储与指向,因此我们拷贝构造的指针就与原指针指向不同的内存地址,但是他们的值在拷贝时是一致的.因此由于指向内存地址不同,因此就不过发生浅拷贝所引发的非法操作问题

- 实例

  - 浅拷贝

    ```c++
    class Person{
    	int age;
        int* heigth;
        Person(int age,int height){
            age = age;
            height = new int(height);
        };
        ~Person(){
            if(height!=NULL){
                delete height;
                height=NULL;
            };
        };
    };
    Person Person1(18,180);
    Person Person2(Person1);
    由于C++的先进后出原则因此函数结束时先释放Person2,再释放Person1,并且此时使用的是编译器自动实现的浅拷贝
    问题:
    前提Person1与Person2的height指针指向同一内存地址
    先释放Person2时,height的内存地址通过析构函数被释放了
    再来释放Person1时,又会对上一步同一个地址再次释放,这是系统不允许的,因此会出现错误
    ```

  - 深拷贝

    ```C++
    class Person{
    	int age;
        int* heigth;
        Person(int age,int height){
            age = age;
            height = new int(height);
        };
        ~Person(){
            if(height!=NULL){
                delete height;
                height=NULL;
            };
        };
        Person(const Person &P){
            age = P.age;
            heigth = new int(*P.height);
            //height = P.height;此为编译器自己实现的方式
        };
    };
    Person Person1(18,180);
    Person Person2(Person1);
    由于C++的先进后出原则因此函数结束时先释放Person2,再释放Person1,并且此时使用的是我们自己实现的深拷贝,因此不会出现浅拷贝的问题
    ```

##### 基于初始化列表以及构造函数的类属性初始化

- 基本语法
  - `类名(参数):属性1(值1),属性2(值2)...{语句体}`
  - `类名(参数1,参数2...):属性1(参数1),属性2(参数2)...{语句体}`
  
- 作用:用在构造函数上,用于给指定的属性分配初值

- ```c++
  class Person{
  	int m_age;
  	string m_name;
  	Person(int age,string name):m_age(age),m_name(name){
  		
  	}
  }
  ```

  

##### 类中的类

- 作用:让指定的类作为其他类的成员属性,并可以通过`.`方法来调用类成员的属性

- **注意**:在主类构造时,其类成员先被构造完成,然后我们的主类才被构造完成.当主类销毁时,先销毁主类,再销毁类成员

- 实例

  - ```C++
    class Student{
    public:
    	string S_name;
    	int S_age;
    	Student(string name,int age){
    		S_name = name;
    		S_age = age;
    	};
    };
    class Teacher{
    public:
    	string T_name;
    	int T_age;
    	Student ZH;
    	Teacher(string name,int age,Student ZH){
    		T_name = name;
    		T_age = age;
    		this->ZH.S_name = ZH.S_name;
    		this->ZH.S_age = ZH.S_age;
    	};
    };
    Student ZhangSan = Student('ZhangSan',16);
    Teacher LiSi = Teacher('LiSi',38,ZhangSan);
    ```

    

##### 静态变量

- 特性

  - **所有的实例化对象共享一个静态变量**,**一个实例化对象修改了静态变量,那么其他实例化对象在访问该静态变量时,就得到的是修改后的值**
  - 在**编译阶段**静态变量便分配好了内存在全局区(一般的成员变量是在类实例化时获得内存分配,并且实例化多个类对象就会有**多个****存储在不同内存地址**的从属于不同类对象的成员变量)
  - 我们的静态变量需要在类内部进行定义,但是**其初始化必须在比当前类高一层级或以上的作用域进行**.

- 访问

  - 通过实例化类对象访问
  - 直接使用类名进行访问,无需实例化的类对象

- ```c++
  class Person{
  	static int num;
  };
  int Person::num = 100;
  void main(void)
  {
      Person ZhangSan;
      Person LiSi;
      //使用实例化对像访问
      cout << ZhangSan.num << endl;
      //探查不同对象共享同一静态变量的特性
      LiSi.num = 22;
      cout << ZhangSan.num << endl;
      
      //使用类名直接访问
      cout << Person::num << endl;
  }
  
  ```

##### 静态成员函数

- **特性**

  - 静态成员函数**只能访问静态变量**
  - 静态成员函数无需其所在类实例化便可通过`类名::静态函数名(参数)`的方式调用
  - 静态成员函数在编译阶段便进行了内存分配

- **访问**

  - 通过类名直接访问
  - 通过类实例进行访问

- ```C++
  class Person{
  public:
  	static Func(){
  		cout << '调用了静态函数Func' << endl;
  	};
  };
  void main(){
      //直接类名访问
      Person::Func();
      Person ZhangSan;
      ZhangSan.Func();
  };
  ```

##### 成员与成员函数的分离存储特性

- 我们`C++`中成员属性与成员函数有不同的保存规则

- :one: **成员属性**

  - 每一个实例化对象都拥有其自己的成员属性,其成员属性各自占据内存空间,不与其他类对象共享内存空间

- :two: **成员函数**

  - 每一个类对象的成员函数都是与其他的类对象共享使用的同一个成员函数.其与静态成员函数的不同在于,其可以访问对应类对象的非静态成员属性,而且其不可以通过类名直接访问(当然其可以使用空指针访问).

- :red_circle: **注意**:如果我们用`sizeof`来探查一个类实例的占用内存大小就会发现**我们获取到的内存只是该类实例的==所有非静态成员属性==所占据的内存大小**,而其**成员函数,静态成员属性,静态成员函数都==不会算入==该类实例的内存占用**,因为他们与类的非静态成员属性是分开保存的并且他们是被所有的类对象共享使用的

- ```C++
  class Person{
  	int num;
  	static int Snum;
  	static void Func(){
  		cout << "静态函数" << endl;
  	};
  	void Func(){
  		cout << "非静态函数" << endl;
  	};
  };
  int Person::Snum = 102;
  void main(){
  	Person SS;
  	cout << sizeof(SS) << endl;
  };
  ```

##### `this`指针

- **背景**:由于类的成员函数是被共享使用的,因此`C++`的每一个成员函数都会自动维护一个`this`指针,其指向调用该成员函数的类实例.

- **作用**

  - :one: 当成员函数的形式参数与类的成员属性名称相同时(**我们的成员函数会直接把函数内部所有的与形式参数名称相同的变量解释为形式参数,而不会解释为类成员函数**),便可以使用`this->成员属性名`的方式来解决这一问题
  - :two: 我们可以给成员函数的返回值返回`*this`(此时成员函数要用`类名&`来修饰)从而实现`.`方法的链式调用

- ```C++
  class Person{
      int age;
      Person(int age){
          this->age = age;
      };
  };
  ```

- ```C++
  class Person{
  	int age = 0;
      Person& Func(){
          this->age += 1;
          return *this;
      };
  };
  int main(){
   	Person ZS;
      ZS.Func().Func().Func();
  };
  ```

##### 空指针访问

- **作用**:用于在不实例化类对象的情况下调用成员函数,值得注意的是我们是不可以访问成员属性的,因为空指针是没有成员属性的.

- **实例**

  ```C++
  class Person{
  	int age;
      void Func(){
          /*if(this==NULL){
              return;
          };*/
          cout << 调用Func函数 << endl;
      };
  };
  void main(){
      Person* ZS = NULL;
  	ZS->Func();
      *ZS.Func();
  };
  ```

##### `const`修饰成员函数

- **作用**:这样定义的成员函数虽然可以读取成员属性,但是其不能修改成员属性的值(当然,如果成员属性在定义时使用了`mutable`关键字进行修饰,那么就能被修改)

- **语法**:`返回值类型 函数名() const {语句体}`

  ```C++
  class Person {
  public:
      int age;
      mutable int M_age;
      void Func() const {
          //age = 10;
          //cout << age << endl;
          M_age = 10;
          cout << M_age << endl;
      };
  };
  void main() {
      Person ZS;
      ZS.Func();
  };
  ```

##### `const`在类对象实例化时使用

- **作用**:将该类实例定义为常对象

- **特性**

  - :one:常对象**可以**访问常函数
  - :two:常对象可以访问声明时使用`mutable`修饰的成员属性
  - :three:常对象**不能**访问成员属性
  - :four:常对象**不能**访问成员函数
  - :five:常函数**可以**访问静态成员函数与静态成员属性

- ```C++
  class Person {
  public:
      static int Sage;
      int age;
      mutable int M_age;
      void Func() const {
          //age = 10;
          //cout << age << endl;
          M_age = 10;
          cout << M_age << endl;
      };
  };
  void main() {
      const Person ZS;
      ZS.Sage;
      //ZS.age;
      //ZS.M_age;
      cout << ZS.age << endl;
  };
  ```

##### 友元

- **前提**:我们知道对于私有权限的成员属性与成员函数,除了我们的类对象内部的函数以外是无法被外接访问的.

- **作用**:通过`friend`关键字来指定`成员函数`,`类`,`全局函数`作为友元,让他们可以访问授予他们友元权限的类的内部``私有成员属性``或者``私有成员函数**``**

- **全局函数做友元**

  - :one:**语法**:`friend 全局函数的声明`
  - :two:**作用**:让该全局函数**可以**访问**该类实例**的私有成员属性与私有成员函数

- **成员函数做友元**

  - :one:**语法**:`friend 成员函数返回值类型 成员函数所属类::成员函数名(参数声明)`
  - :two:**作用**:让该``指定的成员函数``**可以**访问该**类实例**的私有成员属性与私有成员函数

- **类做友元**

  - :one:**语法**:`friend 类名`
  - :two:**作用**:让该类的**所有成员函数**都可以访问授权友元权限的类的实例的任何私有成员属性与私有成员函数

- ```C++
  #include<iostream>
  #include<string>
  using namespace std;
  class Person;
  void GloFunc(Person& P);
  class GoodGay {
  public:
      Person* P;
      GoodGay();
  public:
      void Visit1();
  };
  class Person {
      friend void GoodGay::Visit1();
  private:
      int num = 10;
      void Func() {
          cout << "调用私有函数" << endl;
      };
      friend void GloFunc(Person& P);
      friend class Test;
  };
  GoodGay::GoodGay() {
      P = new Person;
  };
  void GoodGay::Visit1() {
      P->Func();
  };
  class Test {
  public:
      Person* P = new Person;
      void Func() {
          P->Func();
          cout << P->num << endl;
      };
  };
  void GloFunc(Person& P) {
      P.Func();
      cout << P.num << endl;
  }
  void main() {
      Person P;
      Test T;
      GoodGay S;
      S.Visit1();
      T.Func();
  };
  
  ```

##### ==重大问题==

- 关于成员函数做友元时可能会遇到的难以解决的一个问题

- 错误的原因:我们的错误来源于我们对`C++`的声明机制的错误理解

- 错误示范

  ```C++
  #include<iostream>
  #include<string>
  using namespace std;
  class GoodGay;
  class Person {
      friend void GoodGay::Visit1();
  private:
      int num = 10;
      void Func() {
          cout << "调用私有函数" << endl;
      };
  };
  class GoodGay {
  public:
      Person* P;
      GoodGay();
  public:
      void Visit1();
  };
  GoodGay::GoodGay() {
      P = new Person;
  };
  void GoodGay::Visit1() {
      P->Func();
  };
  void main() {
      GoodGay S;
      S.Visit1();
  };
  
  ```

- 正确示范

  ```c++
  #include<iostream>
  #include<string>
  using namespace std;
  class Person;
  class GoodGay;
  class GoodGay {
  public:
      Person* P;
      GoodGay();
  public:
      void Visit1();
  };
  class Person {
      friend void GoodGay::Visit1();
  private:
      int num = 10;
      void Func() {
          cout << "调用私有函数" << endl;
      };
  };
  GoodGay::GoodGay() {
      P = new Person;
  };
  void GoodGay::Visit1() {
      P->Func();
  };
  void main() {
      GoodGay S;
      S.Visit1();
  };
  ```

##### ==链式函数调用==

##### 运算符重载

##### 常见运算符对应的函数名称

- 

##### 加号重载

##### 左移运算符重载

##### 递增运算符重载

##### 赋值重载

##### 关系符号重载

##### 函数调用重载

### 继承

### 基础知识

| 语句        | 比较    |
| ----------- | ------- |
| 条件判断    | 与C一致 |
| 循环        | 与C一致 |
| switch case | 与C一致 |
| 一维数组    | 与C一致 |
| 二维数组    | 与C一致 |
| 函数的定义  | 与C一致 |
| 函数调用    | 与C一致 |
|             |         |

#### 函数的分文件编写

- 编写用于函数声明的`.h`文件
- 编写函数语句体所在的`.cpp`文件
- 使用时先#`include "h文件名.h"`
- 然后直接调用函数

#### `const 数据类型*`与`数据类型* const`

- **第一种定义**的指针的指向可以改变,但是不可以通过该指针修改其指向的变量的值
- **第二种定义**的指针的指向可以改变,但可以通过该指针修改其指向的变量的值

#### cin/cout

- 作用
  - `cin`:获取用户输入
  - `cout`:向用户输出
- 字符
  - `>>`:输入流
  - '<<':输出流
  - `endl`:结束标志符号

#### 变量,常量命名规则

- 不能是关键字
- 只能由字母,数字,下划线组成
- 区分大小写
- 必须由下划线或字母开头

#### 三目运算符

- `表达式1` ? `表达式2` : `表达式3`

  ```C++
  等价于:
  if(表达式1){
  	表达式2
  }
  else{
  	表达式3
  }
  ```

#### goto

- 作用:跳转到指定标志处执行

```C++
goto <标志名>

<标志名>:
	语句体
```

#### include<>与include ""

#### 常用技巧

| 技巧             | 作用                                 |
| ---------------- | ------------------------------------ |
| aeb              | 等价于a×10^b                         |
| (数据类型)变量名 | 将变量的数据类型强制转换为指定的类型 |
|                  |                                      |
|                  |                                      |
|                  |                                      |
|                  |                                      |
|                  |                                      |
|                  |                                      |
|                  |                                      |

#### 常用函数

| 函数     | 作用                                        |
| -------- | ------------------------------------------- |
| sizeof() | 求得指定变量或数据类型的所占字节数,静态函数 |
|          |                                             |
|          |                                             |
|          |                                             |
|          |                                             |
|          |                                             |
|          |                                             |
|          |                                             |
|          |                                             |

